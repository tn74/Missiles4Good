// Copyright (C) 2017  Intel Corporation. All rights reserved.
// Your use of Intel Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Intel Program License 
// Subscription Agreement, the Intel Quartus Prime License Agreement,
// the Intel FPGA IP License Agreement, or other applicable license
// agreement, including, without limitation, that your use is for
// the sole purpose of programming logic devices manufactured by
// Intel and sold by Intel or its authorized distributors.  Please
// refer to the applicable agreement for further details.

// *****************************************************************************
// This file contains a Verilog test bench with test vectors .The test vectors  
// are exported from a vector file in the Quartus Waveform Editor and apply to  
// the top level entity of the current Quartus project .The user can use this   
// testbench to simulate his design using a third-party simulation tool .       
// *****************************************************************************
// Generated on "12/02/2018 19:19:43"
                                                                                
// Verilog Test Bench (with test vectors) for design :                          index_mif_writer
// 
// Simulation tool : 3rd Party
// 

`timescale 1 ps/ 1 ps
module index_mif_writer_vlg_vec_tst();
// constants                                           
// general purpose registers
reg [7:0] angle;
reg clock;
reg fire;
reg [31:0] targetx_0;
reg [31:0] targetx_1;
reg [31:0] targetx_2;
reg [31:0] targetx_3;
reg [31:0] targety_0;
reg [31:0] targety_1;
reg [31:0] targety_2;
reg [31:0] targety_3;
reg [31:0] trajectory_memloc;
reg [31:0] trajectory_memloc_enable;
reg [7:0] velocity;
// wires                                               
wire [31:0] count_out;
wire [18:0] mem_waddr;
wire [2:0] mem_wdata;
wire mem_wenable;
wire typer_busy_out;
wire typer_finish_out;
wire typer_start_out;

// assign statements (if any)                          
index_mif_writer i1 (
// port map - connection between master ports and signals/registers   
	.angle(angle),
	.clock(clock),
	.count_out(count_out),
	.fire(fire),
	.mem_waddr(mem_waddr),
	.mem_wdata(mem_wdata),
	.mem_wenable(mem_wenable),
	.targetx_0(targetx_0),
	.targetx_1(targetx_1),
	.targetx_2(targetx_2),
	.targetx_3(targetx_3),
	.targety_0(targety_0),
	.targety_1(targety_1),
	.targety_2(targety_2),
	.targety_3(targety_3),
	.trajectory_memloc(trajectory_memloc),
	.trajectory_memloc_enable(trajectory_memloc_enable),
	.typer_busy_out(typer_busy_out),
	.typer_finish_out(typer_finish_out),
	.typer_start_out(typer_start_out),
	.velocity(velocity)
);
initial 
begin 
#15000000 $finish;
end 

// clock
initial
begin
	repeat(599)
	begin
		clock = 1'b0;
		clock = #10000 1'b1;
		# 10000;
	end
	clock = 1'b0;
	clock = #10000 1'b1;
	# 9000;
	repeat(150)
	begin
		clock = 1'b0;
		clock = #10000 1'b1;
		# 10000;
	end
	clock = 1'b0;
end 
endmodule

